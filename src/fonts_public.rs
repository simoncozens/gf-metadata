// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc --rs_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `fonts_public.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:google.fonts_public.FamilyProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FamilyProto {
    // message fields
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.designer)
    pub designer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.license)
    pub license: ::std::option::Option<::std::string::String>,
    ///  A mutually-exclusive category for each font. The categories are: Serif,
    ///  Sans Serif, Display, Handwriting and Monospace. Being mutually exclusive is
    ///  a significant deficiency as, for example, most Display fonts are typically
    ///  Serif or Sans Serif and that is not captured.
    ///
    ///  For searching, this field is replaced by stroke and classifications (see
    ///  below), however, this field persists (it's required after all) and will
    ///  continue to be populated in the onboarding process.
    ///
    ///  This is repeated field, yet Google Fonts only uses the last entry so
    ///  multiple entries should be avoided.
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.category)
    pub category: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.date_added)
    pub date_added: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.fonts)
    pub fonts: ::std::vec::Vec<FontProto>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.aliases)
    pub aliases: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.subsets)
    pub subsets: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.ttf_autohint_args)
    pub ttf_autohint_args: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.axes)
    pub axes: ::std::vec::Vec<AxisSegmentProto>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.registry_default_overrides)
    pub registry_default_overrides: ::std::collections::HashMap<::std::string::String, f32>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.source)
    pub source: ::protobuf::MessageField<SourceProto>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.is_noto)
    pub is_noto: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.languages)
    pub languages: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.fallbacks)
    pub fallbacks: ::std::vec::Vec<FamilyFallbackProto>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.sample_glyphs)
    pub sample_glyphs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.sample_text)
    pub sample_text: ::protobuf::MessageField<SampleTextProto>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.display_name)
    pub display_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.ordered_sample_glyphs)
    pub ordered_sample_glyphs: ::std::vec::Vec<GlyphGroupProto>,
    ///  Optional url for more info about the font.
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.minisite_url)
    pub minisite_url: ::std::option::Option<::std::string::String>,
    ///  The script to use when picking sample text. See the Script spanner table.
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.primary_script)
    pub primary_script: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.primary_language)
    pub primary_language: ::std::option::Option<::std::string::String>,
    ///  Stroke of the letter forms: serif, sans serif, etc. Stroke is mutually
    ///  exclusive. The values are the string names from the Stroke enum or the
    ///  empty string.
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.stroke)
    pub stroke: ::std::option::Option<::std::string::String>,
    ///  A family's broad classifications: display, handwriting, monospace, etc.
    ///  The values are the string names from the Classification enum.
    // @@protoc_insertion_point(field:google.fonts_public.FamilyProto.classifications)
    pub classifications: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.fonts_public.FamilyProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FamilyProto {
    fn default() -> &'a FamilyProto {
        <FamilyProto as ::protobuf::Message>::default_instance()
    }
}

impl FamilyProto {
    pub fn new() -> FamilyProto {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string designer = 2;

    pub fn designer(&self) -> &str {
        match self.designer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_designer(&mut self) {
        self.designer = ::std::option::Option::None;
    }

    pub fn has_designer(&self) -> bool {
        self.designer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_designer(&mut self, v: ::std::string::String) {
        self.designer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_designer(&mut self) -> &mut ::std::string::String {
        if self.designer.is_none() {
            self.designer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.designer.as_mut().unwrap()
    }

    // Take field
    pub fn take_designer(&mut self) -> ::std::string::String {
        self.designer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string license = 3;

    pub fn license(&self) -> &str {
        match self.license.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_license(&mut self) {
        self.license = ::std::option::Option::None;
    }

    pub fn has_license(&self) -> bool {
        self.license.is_some()
    }

    // Param is passed by value, moved
    pub fn set_license(&mut self, v: ::std::string::String) {
        self.license = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_license(&mut self) -> &mut ::std::string::String {
        if self.license.is_none() {
            self.license = ::std::option::Option::Some(::std::string::String::new());
        }
        self.license.as_mut().unwrap()
    }

    // Take field
    pub fn take_license(&mut self) -> ::std::string::String {
        self.license.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string date_added = 5;

    pub fn date_added(&self) -> &str {
        match self.date_added.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_date_added(&mut self) {
        self.date_added = ::std::option::Option::None;
    }

    pub fn has_date_added(&self) -> bool {
        self.date_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date_added(&mut self, v: ::std::string::String) {
        self.date_added = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date_added(&mut self) -> &mut ::std::string::String {
        if self.date_added.is_none() {
            self.date_added = ::std::option::Option::Some(::std::string::String::new());
        }
        self.date_added.as_mut().unwrap()
    }

    // Take field
    pub fn take_date_added(&mut self) -> ::std::string::String {
        self.date_added.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ttf_autohint_args = 9;

    pub fn ttf_autohint_args(&self) -> &str {
        match self.ttf_autohint_args.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ttf_autohint_args(&mut self) {
        self.ttf_autohint_args = ::std::option::Option::None;
    }

    pub fn has_ttf_autohint_args(&self) -> bool {
        self.ttf_autohint_args.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ttf_autohint_args(&mut self, v: ::std::string::String) {
        self.ttf_autohint_args = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ttf_autohint_args(&mut self) -> &mut ::std::string::String {
        if self.ttf_autohint_args.is_none() {
            self.ttf_autohint_args = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ttf_autohint_args.as_mut().unwrap()
    }

    // Take field
    pub fn take_ttf_autohint_args(&mut self) -> ::std::string::String {
        self.ttf_autohint_args.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_noto = 13;

    pub fn is_noto(&self) -> bool {
        self.is_noto.unwrap_or(false)
    }

    pub fn clear_is_noto(&mut self) {
        self.is_noto = ::std::option::Option::None;
    }

    pub fn has_is_noto(&self) -> bool {
        self.is_noto.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_noto(&mut self, v: bool) {
        self.is_noto = ::std::option::Option::Some(v);
    }

    // optional string display_name = 18;

    pub fn display_name(&self) -> &str {
        match self.display_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_display_name(&mut self) {
        self.display_name = ::std::option::Option::None;
    }

    pub fn has_display_name(&self) -> bool {
        self.display_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        if self.display_name.is_none() {
            self.display_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.display_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string minisite_url = 20;

    pub fn minisite_url(&self) -> &str {
        match self.minisite_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_minisite_url(&mut self) {
        self.minisite_url = ::std::option::Option::None;
    }

    pub fn has_minisite_url(&self) -> bool {
        self.minisite_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minisite_url(&mut self, v: ::std::string::String) {
        self.minisite_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minisite_url(&mut self) -> &mut ::std::string::String {
        if self.minisite_url.is_none() {
            self.minisite_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.minisite_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_minisite_url(&mut self) -> ::std::string::String {
        self.minisite_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string primary_script = 21;

    pub fn primary_script(&self) -> &str {
        match self.primary_script.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_primary_script(&mut self) {
        self.primary_script = ::std::option::Option::None;
    }

    pub fn has_primary_script(&self) -> bool {
        self.primary_script.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_script(&mut self, v: ::std::string::String) {
        self.primary_script = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_script(&mut self) -> &mut ::std::string::String {
        if self.primary_script.is_none() {
            self.primary_script = ::std::option::Option::Some(::std::string::String::new());
        }
        self.primary_script.as_mut().unwrap()
    }

    // Take field
    pub fn take_primary_script(&mut self) -> ::std::string::String {
        self.primary_script.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string primary_language = 22;

    pub fn primary_language(&self) -> &str {
        match self.primary_language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_primary_language(&mut self) {
        self.primary_language = ::std::option::Option::None;
    }

    pub fn has_primary_language(&self) -> bool {
        self.primary_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_language(&mut self, v: ::std::string::String) {
        self.primary_language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_primary_language(&mut self) -> &mut ::std::string::String {
        if self.primary_language.is_none() {
            self.primary_language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.primary_language.as_mut().unwrap()
    }

    // Take field
    pub fn take_primary_language(&mut self) -> ::std::string::String {
        self.primary_language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string stroke = 23;

    pub fn stroke(&self) -> &str {
        match self.stroke.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stroke(&mut self) {
        self.stroke = ::std::option::Option::None;
    }

    pub fn has_stroke(&self) -> bool {
        self.stroke.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stroke(&mut self, v: ::std::string::String) {
        self.stroke = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stroke(&mut self) -> &mut ::std::string::String {
        if self.stroke.is_none() {
            self.stroke = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stroke.as_mut().unwrap()
    }

    // Take field
    pub fn take_stroke(&mut self) -> ::std::string::String {
        self.stroke.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &FamilyProto| { &m.name },
            |m: &mut FamilyProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "designer",
            |m: &FamilyProto| { &m.designer },
            |m: &mut FamilyProto| { &mut m.designer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "license",
            |m: &FamilyProto| { &m.license },
            |m: &mut FamilyProto| { &mut m.license },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "category",
            |m: &FamilyProto| { &m.category },
            |m: &mut FamilyProto| { &mut m.category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "date_added",
            |m: &FamilyProto| { &m.date_added },
            |m: &mut FamilyProto| { &mut m.date_added },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fonts",
            |m: &FamilyProto| { &m.fonts },
            |m: &mut FamilyProto| { &mut m.fonts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "aliases",
            |m: &FamilyProto| { &m.aliases },
            |m: &mut FamilyProto| { &mut m.aliases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subsets",
            |m: &FamilyProto| { &m.subsets },
            |m: &mut FamilyProto| { &mut m.subsets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ttf_autohint_args",
            |m: &FamilyProto| { &m.ttf_autohint_args },
            |m: &mut FamilyProto| { &mut m.ttf_autohint_args },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "axes",
            |m: &FamilyProto| { &m.axes },
            |m: &mut FamilyProto| { &mut m.axes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "registry_default_overrides",
            |m: &FamilyProto| { &m.registry_default_overrides },
            |m: &mut FamilyProto| { &mut m.registry_default_overrides },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SourceProto>(
            "source",
            |m: &FamilyProto| { &m.source },
            |m: &mut FamilyProto| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_noto",
            |m: &FamilyProto| { &m.is_noto },
            |m: &mut FamilyProto| { &mut m.is_noto },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &FamilyProto| { &m.languages },
            |m: &mut FamilyProto| { &mut m.languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fallbacks",
            |m: &FamilyProto| { &m.fallbacks },
            |m: &mut FamilyProto| { &mut m.fallbacks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "sample_glyphs",
            |m: &FamilyProto| { &m.sample_glyphs },
            |m: &mut FamilyProto| { &mut m.sample_glyphs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SampleTextProto>(
            "sample_text",
            |m: &FamilyProto| { &m.sample_text },
            |m: &mut FamilyProto| { &mut m.sample_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_name",
            |m: &FamilyProto| { &m.display_name },
            |m: &mut FamilyProto| { &mut m.display_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ordered_sample_glyphs",
            |m: &FamilyProto| { &m.ordered_sample_glyphs },
            |m: &mut FamilyProto| { &mut m.ordered_sample_glyphs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minisite_url",
            |m: &FamilyProto| { &m.minisite_url },
            |m: &mut FamilyProto| { &mut m.minisite_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_script",
            |m: &FamilyProto| { &m.primary_script },
            |m: &mut FamilyProto| { &mut m.primary_script },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_language",
            |m: &FamilyProto| { &m.primary_language },
            |m: &mut FamilyProto| { &mut m.primary_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stroke",
            |m: &FamilyProto| { &m.stroke },
            |m: &mut FamilyProto| { &mut m.stroke },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "classifications",
            |m: &FamilyProto| { &m.classifications },
            |m: &mut FamilyProto| { &mut m.classifications },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FamilyProto>(
            "FamilyProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FamilyProto {
    const NAME: &'static str = "FamilyProto";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.designer.is_none() {
            return false;
        }
        if self.license.is_none() {
            return false;
        }
        if self.date_added.is_none() {
            return false;
        }
        for v in &self.fonts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.axes {
            if !v.is_initialized() {
                return false;
            }
        };
        // TODO: check map values are initialized
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fallbacks {
            if !v.is_initialized() {
                return false;
            }
        };
        // TODO: check map values are initialized
        for v in &self.sample_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ordered_sample_glyphs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.designer = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.license = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.category.push(is.read_string()?);
                },
                42 => {
                    self.date_added = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.fonts.push(is.read_message()?);
                },
                58 => {
                    self.aliases.push(is.read_string()?);
                },
                66 => {
                    self.subsets.push(is.read_string()?);
                },
                74 => {
                    self.ttf_autohint_args = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.axes.push(is.read_message()?);
                },
                90 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            21 => value = is.read_float()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.registry_default_overrides.insert(key, value);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source)?;
                },
                104 => {
                    self.is_noto = ::std::option::Option::Some(is.read_bool()?);
                },
                114 => {
                    self.languages.push(is.read_string()?);
                },
                122 => {
                    self.fallbacks.push(is.read_message()?);
                },
                130 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.sample_glyphs.insert(key, value);
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sample_text)?;
                },
                146 => {
                    self.display_name = ::std::option::Option::Some(is.read_string()?);
                },
                154 => {
                    self.ordered_sample_glyphs.push(is.read_message()?);
                },
                162 => {
                    self.minisite_url = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.primary_script = ::std::option::Option::Some(is.read_string()?);
                },
                178 => {
                    self.primary_language = ::std::option::Option::Some(is.read_string()?);
                },
                186 => {
                    self.stroke = ::std::option::Option::Some(is.read_string()?);
                },
                202 => {
                    self.classifications.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.designer.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.license.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.category {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.date_added.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.fonts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.aliases {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.subsets {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.ttf_autohint_args.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.axes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.registry_default_overrides {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += 1 + 4;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.is_noto {
            my_size += 1 + 1;
        }
        for value in &self.languages {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        for value in &self.fallbacks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for (k, v) in &self.sample_glyphs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if let Some(v) = self.sample_text.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.display_name.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        for value in &self.ordered_sample_glyphs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.minisite_url.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.primary_script.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.primary_language.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.stroke.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        for value in &self.classifications {
            my_size += ::protobuf::rt::string_size(25, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.designer.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.license.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.category {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.date_added.as_ref() {
            os.write_string(5, v)?;
        }
        for v in &self.fonts {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.aliases {
            os.write_string(7, &v)?;
        };
        for v in &self.subsets {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.ttf_autohint_args.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.axes {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for (k, v) in &self.registry_default_overrides {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += 1 + 4;
            os.write_raw_varint32(90)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_float(2, *v)?;
        };
        if let Some(v) = self.source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.is_noto {
            os.write_bool(13, v)?;
        }
        for v in &self.languages {
            os.write_string(14, &v)?;
        };
        for v in &self.fallbacks {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        for (k, v) in &self.sample_glyphs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(130)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.sample_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.display_name.as_ref() {
            os.write_string(18, v)?;
        }
        for v in &self.ordered_sample_glyphs {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        if let Some(v) = self.minisite_url.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.primary_script.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.primary_language.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.stroke.as_ref() {
            os.write_string(23, v)?;
        }
        for v in &self.classifications {
            os.write_string(25, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FamilyProto {
        FamilyProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.designer = ::std::option::Option::None;
        self.license = ::std::option::Option::None;
        self.category.clear();
        self.date_added = ::std::option::Option::None;
        self.fonts.clear();
        self.aliases.clear();
        self.subsets.clear();
        self.ttf_autohint_args = ::std::option::Option::None;
        self.axes.clear();
        self.registry_default_overrides.clear();
        self.source.clear();
        self.is_noto = ::std::option::Option::None;
        self.languages.clear();
        self.fallbacks.clear();
        self.sample_glyphs.clear();
        self.sample_text.clear();
        self.display_name = ::std::option::Option::None;
        self.ordered_sample_glyphs.clear();
        self.minisite_url = ::std::option::Option::None;
        self.primary_script = ::std::option::Option::None;
        self.primary_language = ::std::option::Option::None;
        self.stroke = ::std::option::Option::None;
        self.classifications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FamilyProto {
        static instance: ::protobuf::rt::Lazy<FamilyProto> = ::protobuf::rt::Lazy::new();
        instance.get(FamilyProto::new)
    }
}

impl ::protobuf::MessageFull for FamilyProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FamilyProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FamilyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FamilyProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.fonts_public.FontProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FontProto {
    // message fields
    // @@protoc_insertion_point(field:google.fonts_public.FontProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FontProto.style)
    pub style: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FontProto.weight)
    pub weight: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.fonts_public.FontProto.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FontProto.post_script_name)
    pub post_script_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FontProto.full_name)
    pub full_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.FontProto.copyright)
    pub copyright: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.fonts_public.FontProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FontProto {
    fn default() -> &'a FontProto {
        <FontProto as ::protobuf::Message>::default_instance()
    }
}

impl FontProto {
    pub fn new() -> FontProto {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string style = 2;

    pub fn style(&self) -> &str {
        match self.style.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: ::std::string::String) {
        self.style = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_style(&mut self) -> &mut ::std::string::String {
        if self.style.is_none() {
            self.style = ::std::option::Option::Some(::std::string::String::new());
        }
        self.style.as_mut().unwrap()
    }

    // Take field
    pub fn take_style(&mut self) -> ::std::string::String {
        self.style.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 weight = 3;

    pub fn weight(&self) -> i32 {
        self.weight.unwrap_or(0)
    }

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = ::std::option::Option::Some(v);
    }

    // required string filename = 4;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string post_script_name = 5;

    pub fn post_script_name(&self) -> &str {
        match self.post_script_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_post_script_name(&mut self) {
        self.post_script_name = ::std::option::Option::None;
    }

    pub fn has_post_script_name(&self) -> bool {
        self.post_script_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_post_script_name(&mut self, v: ::std::string::String) {
        self.post_script_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_post_script_name(&mut self) -> &mut ::std::string::String {
        if self.post_script_name.is_none() {
            self.post_script_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.post_script_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_post_script_name(&mut self) -> ::std::string::String {
        self.post_script_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string full_name = 6;

    pub fn full_name(&self) -> &str {
        match self.full_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_full_name(&mut self) {
        self.full_name = ::std::option::Option::None;
    }

    pub fn has_full_name(&self) -> bool {
        self.full_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_name(&mut self, v: ::std::string::String) {
        self.full_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_name(&mut self) -> &mut ::std::string::String {
        if self.full_name.is_none() {
            self.full_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.full_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_name(&mut self) -> ::std::string::String {
        self.full_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string copyright = 7;

    pub fn copyright(&self) -> &str {
        match self.copyright.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_copyright(&mut self) {
        self.copyright = ::std::option::Option::None;
    }

    pub fn has_copyright(&self) -> bool {
        self.copyright.is_some()
    }

    // Param is passed by value, moved
    pub fn set_copyright(&mut self, v: ::std::string::String) {
        self.copyright = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_copyright(&mut self) -> &mut ::std::string::String {
        if self.copyright.is_none() {
            self.copyright = ::std::option::Option::Some(::std::string::String::new());
        }
        self.copyright.as_mut().unwrap()
    }

    // Take field
    pub fn take_copyright(&mut self) -> ::std::string::String {
        self.copyright.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &FontProto| { &m.name },
            |m: &mut FontProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style",
            |m: &FontProto| { &m.style },
            |m: &mut FontProto| { &mut m.style },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weight",
            |m: &FontProto| { &m.weight },
            |m: &mut FontProto| { &mut m.weight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &FontProto| { &m.filename },
            |m: &mut FontProto| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "post_script_name",
            |m: &FontProto| { &m.post_script_name },
            |m: &mut FontProto| { &mut m.post_script_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "full_name",
            |m: &FontProto| { &m.full_name },
            |m: &mut FontProto| { &mut m.full_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "copyright",
            |m: &FontProto| { &m.copyright },
            |m: &mut FontProto| { &mut m.copyright },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FontProto>(
            "FontProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FontProto {
    const NAME: &'static str = "FontProto";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.style.is_none() {
            return false;
        }
        if self.weight.is_none() {
            return false;
        }
        if self.filename.is_none() {
            return false;
        }
        if self.post_script_name.is_none() {
            return false;
        }
        if self.full_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.style = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.weight = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.post_script_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.full_name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.copyright = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.style.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.post_script_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.full_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.copyright.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.style.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.weight {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.post_script_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.full_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.copyright.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FontProto {
        FontProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.weight = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.post_script_name = ::std::option::Option::None;
        self.full_name = ::std::option::Option::None;
        self.copyright = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FontProto {
        static instance: FontProto = FontProto {
            name: ::std::option::Option::None,
            style: ::std::option::Option::None,
            weight: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            post_script_name: ::std::option::Option::None,
            full_name: ::std::option::Option::None,
            copyright: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FontProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FontProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FontProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FontProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.fonts_public.AxisSegmentProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AxisSegmentProto {
    // message fields
    // @@protoc_insertion_point(field:google.fonts_public.AxisSegmentProto.tag)
    pub tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.AxisSegmentProto.min_value)
    pub min_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:google.fonts_public.AxisSegmentProto.max_value)
    pub max_value: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:google.fonts_public.AxisSegmentProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AxisSegmentProto {
    fn default() -> &'a AxisSegmentProto {
        <AxisSegmentProto as ::protobuf::Message>::default_instance()
    }
}

impl AxisSegmentProto {
    pub fn new() -> AxisSegmentProto {
        ::std::default::Default::default()
    }

    // optional string tag = 1;

    pub fn tag(&self) -> &str {
        match self.tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tag(&mut self) {
        self.tag = ::std::option::Option::None;
    }

    pub fn has_tag(&self) -> bool {
        self.tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        if self.tag.is_none() {
            self.tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        self.tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float min_value = 2;

    pub fn min_value(&self) -> f32 {
        self.min_value.unwrap_or(0.)
    }

    pub fn clear_min_value(&mut self) {
        self.min_value = ::std::option::Option::None;
    }

    pub fn has_min_value(&self) -> bool {
        self.min_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_value(&mut self, v: f32) {
        self.min_value = ::std::option::Option::Some(v);
    }

    // optional float max_value = 4;

    pub fn max_value(&self) -> f32 {
        self.max_value.unwrap_or(0.)
    }

    pub fn clear_max_value(&mut self) {
        self.max_value = ::std::option::Option::None;
    }

    pub fn has_max_value(&self) -> bool {
        self.max_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_value(&mut self, v: f32) {
        self.max_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tag",
            |m: &AxisSegmentProto| { &m.tag },
            |m: &mut AxisSegmentProto| { &mut m.tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_value",
            |m: &AxisSegmentProto| { &m.min_value },
            |m: &mut AxisSegmentProto| { &mut m.min_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_value",
            |m: &AxisSegmentProto| { &m.max_value },
            |m: &mut AxisSegmentProto| { &mut m.max_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AxisSegmentProto>(
            "AxisSegmentProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AxisSegmentProto {
    const NAME: &'static str = "AxisSegmentProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tag = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.min_value = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.max_value = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tag.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.min_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_value {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tag.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.min_value {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.max_value {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AxisSegmentProto {
        AxisSegmentProto::new()
    }

    fn clear(&mut self) {
        self.tag = ::std::option::Option::None;
        self.min_value = ::std::option::Option::None;
        self.max_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AxisSegmentProto {
        static instance: AxisSegmentProto = AxisSegmentProto {
            tag: ::std::option::Option::None,
            min_value: ::std::option::Option::None,
            max_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AxisSegmentProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AxisSegmentProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AxisSegmentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AxisSegmentProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.fonts_public.SourceProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SourceProto {
    // message fields
    // @@protoc_insertion_point(field:google.fonts_public.SourceProto.repository_url)
    pub repository_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SourceProto.branch)
    pub branch: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SourceProto.commit)
    pub commit: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SourceProto.archive_url)
    pub archive_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SourceProto.config_yaml)
    pub config_yaml: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SourceProto.files)
    pub files: ::std::vec::Vec<SourceFileProto>,
    // special fields
    // @@protoc_insertion_point(special_field:google.fonts_public.SourceProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SourceProto {
    fn default() -> &'a SourceProto {
        <SourceProto as ::protobuf::Message>::default_instance()
    }
}

impl SourceProto {
    pub fn new() -> SourceProto {
        ::std::default::Default::default()
    }

    // optional string repository_url = 1;

    pub fn repository_url(&self) -> &str {
        match self.repository_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_repository_url(&mut self) {
        self.repository_url = ::std::option::Option::None;
    }

    pub fn has_repository_url(&self) -> bool {
        self.repository_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repository_url(&mut self, v: ::std::string::String) {
        self.repository_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_repository_url(&mut self) -> &mut ::std::string::String {
        if self.repository_url.is_none() {
            self.repository_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.repository_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_repository_url(&mut self) -> ::std::string::String {
        self.repository_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string branch = 5;

    pub fn branch(&self) -> &str {
        match self.branch.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_branch(&mut self) {
        self.branch = ::std::option::Option::None;
    }

    pub fn has_branch(&self) -> bool {
        self.branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch(&mut self, v: ::std::string::String) {
        self.branch = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_branch(&mut self) -> &mut ::std::string::String {
        if self.branch.is_none() {
            self.branch = ::std::option::Option::Some(::std::string::String::new());
        }
        self.branch.as_mut().unwrap()
    }

    // Take field
    pub fn take_branch(&mut self) -> ::std::string::String {
        self.branch.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string commit = 2;

    pub fn commit(&self) -> &str {
        match self.commit.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_commit(&mut self) {
        self.commit = ::std::option::Option::None;
    }

    pub fn has_commit(&self) -> bool {
        self.commit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit(&mut self, v: ::std::string::String) {
        self.commit = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commit(&mut self) -> &mut ::std::string::String {
        if self.commit.is_none() {
            self.commit = ::std::option::Option::Some(::std::string::String::new());
        }
        self.commit.as_mut().unwrap()
    }

    // Take field
    pub fn take_commit(&mut self) -> ::std::string::String {
        self.commit.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string archive_url = 3;

    pub fn archive_url(&self) -> &str {
        match self.archive_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_archive_url(&mut self) {
        self.archive_url = ::std::option::Option::None;
    }

    pub fn has_archive_url(&self) -> bool {
        self.archive_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_archive_url(&mut self, v: ::std::string::String) {
        self.archive_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_archive_url(&mut self) -> &mut ::std::string::String {
        if self.archive_url.is_none() {
            self.archive_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.archive_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_archive_url(&mut self) -> ::std::string::String {
        self.archive_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string config_yaml = 6;

    pub fn config_yaml(&self) -> &str {
        match self.config_yaml.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_config_yaml(&mut self) {
        self.config_yaml = ::std::option::Option::None;
    }

    pub fn has_config_yaml(&self) -> bool {
        self.config_yaml.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config_yaml(&mut self, v: ::std::string::String) {
        self.config_yaml = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_yaml(&mut self) -> &mut ::std::string::String {
        if self.config_yaml.is_none() {
            self.config_yaml = ::std::option::Option::Some(::std::string::String::new());
        }
        self.config_yaml.as_mut().unwrap()
    }

    // Take field
    pub fn take_config_yaml(&mut self) -> ::std::string::String {
        self.config_yaml.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "repository_url",
            |m: &SourceProto| { &m.repository_url },
            |m: &mut SourceProto| { &mut m.repository_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "branch",
            |m: &SourceProto| { &m.branch },
            |m: &mut SourceProto| { &mut m.branch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commit",
            |m: &SourceProto| { &m.commit },
            |m: &mut SourceProto| { &mut m.commit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "archive_url",
            |m: &SourceProto| { &m.archive_url },
            |m: &mut SourceProto| { &mut m.archive_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "config_yaml",
            |m: &SourceProto| { &m.config_yaml },
            |m: &mut SourceProto| { &mut m.config_yaml },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "files",
            |m: &SourceProto| { &m.files },
            |m: &mut SourceProto| { &mut m.files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SourceProto>(
            "SourceProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SourceProto {
    const NAME: &'static str = "SourceProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.repository_url = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.branch = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.commit = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.archive_url = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.config_yaml = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.files.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.repository_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.branch.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.commit.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.archive_url.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.config_yaml.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.repository_url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.branch.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.commit.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.archive_url.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.config_yaml.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.files {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SourceProto {
        SourceProto::new()
    }

    fn clear(&mut self) {
        self.repository_url = ::std::option::Option::None;
        self.branch = ::std::option::Option::None;
        self.commit = ::std::option::Option::None;
        self.archive_url = ::std::option::Option::None;
        self.config_yaml = ::std::option::Option::None;
        self.files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SourceProto {
        static instance: SourceProto = SourceProto {
            repository_url: ::std::option::Option::None,
            branch: ::std::option::Option::None,
            commit: ::std::option::Option::None,
            archive_url: ::std::option::Option::None,
            config_yaml: ::std::option::Option::None,
            files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SourceProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SourceProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SourceProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  A file to take from source and where to put it in dest
///  Ex web/split/Roboto[wdth,wght].ttf => Roboto[wdth,wght].ttf
// @@protoc_insertion_point(message:google.fonts_public.SourceFileProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SourceFileProto {
    // message fields
    // @@protoc_insertion_point(field:google.fonts_public.SourceFileProto.source_file)
    pub source_file: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SourceFileProto.dest_file)
    pub dest_file: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.fonts_public.SourceFileProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SourceFileProto {
    fn default() -> &'a SourceFileProto {
        <SourceFileProto as ::protobuf::Message>::default_instance()
    }
}

impl SourceFileProto {
    pub fn new() -> SourceFileProto {
        ::std::default::Default::default()
    }

    // optional string source_file = 1;

    pub fn source_file(&self) -> &str {
        match self.source_file.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source_file(&mut self) {
        self.source_file = ::std::option::Option::None;
    }

    pub fn has_source_file(&self) -> bool {
        self.source_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_file(&mut self, v: ::std::string::String) {
        self.source_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_file(&mut self) -> &mut ::std::string::String {
        if self.source_file.is_none() {
            self.source_file = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_file(&mut self) -> ::std::string::String {
        self.source_file.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string dest_file = 2;

    pub fn dest_file(&self) -> &str {
        match self.dest_file.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dest_file(&mut self) {
        self.dest_file = ::std::option::Option::None;
    }

    pub fn has_dest_file(&self) -> bool {
        self.dest_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest_file(&mut self, v: ::std::string::String) {
        self.dest_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dest_file(&mut self) -> &mut ::std::string::String {
        if self.dest_file.is_none() {
            self.dest_file = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dest_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_dest_file(&mut self) -> ::std::string::String {
        self.dest_file.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_file",
            |m: &SourceFileProto| { &m.source_file },
            |m: &mut SourceFileProto| { &mut m.source_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dest_file",
            |m: &SourceFileProto| { &m.dest_file },
            |m: &mut SourceFileProto| { &mut m.dest_file },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SourceFileProto>(
            "SourceFileProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SourceFileProto {
    const NAME: &'static str = "SourceFileProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.source_file = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.dest_file = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_file.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.dest_file.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.source_file.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.dest_file.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SourceFileProto {
        SourceFileProto::new()
    }

    fn clear(&mut self) {
        self.source_file = ::std::option::Option::None;
        self.dest_file = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SourceFileProto {
        static instance: SourceFileProto = SourceFileProto {
            source_file: ::std::option::Option::None,
            dest_file: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SourceFileProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SourceFileProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SourceFileProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceFileProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Message so we can add additional fields like value in future
// @@protoc_insertion_point(message:google.fonts_public.TargetProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TargetProto {
    // message fields
    // @@protoc_insertion_point(field:google.fonts_public.TargetProto.target_type)
    pub target_type: ::std::option::Option<::protobuf::EnumOrUnknown<TargetTypeProto>>,
    // special fields
    // @@protoc_insertion_point(special_field:google.fonts_public.TargetProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TargetProto {
    fn default() -> &'a TargetProto {
        <TargetProto as ::protobuf::Message>::default_instance()
    }
}

impl TargetProto {
    pub fn new() -> TargetProto {
        ::std::default::Default::default()
    }

    // optional .google.fonts_public.TargetTypeProto target_type = 1;

    pub fn target_type(&self) -> TargetTypeProto {
        match self.target_type {
            Some(e) => e.enum_value_or(TargetTypeProto::TARGET_UNSPECIFIED),
            None => TargetTypeProto::TARGET_UNSPECIFIED,
        }
    }

    pub fn clear_target_type(&mut self) {
        self.target_type = ::std::option::Option::None;
    }

    pub fn has_target_type(&self) -> bool {
        self.target_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_type(&mut self, v: TargetTypeProto) {
        self.target_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_type",
            |m: &TargetProto| { &m.target_type },
            |m: &mut TargetProto| { &mut m.target_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TargetProto>(
            "TargetProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TargetProto {
    const NAME: &'static str = "TargetProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TargetProto {
        TargetProto::new()
    }

    fn clear(&mut self) {
        self.target_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TargetProto {
        static instance: TargetProto = TargetProto {
            target_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TargetProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TargetProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TargetProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TargetProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.fonts_public.FamilyFallbackProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FamilyFallbackProto {
    // message fields
    // @@protoc_insertion_point(field:google.fonts_public.FamilyFallbackProto.axis_target)
    pub axis_target: ::std::vec::Vec<AxisSegmentProto>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyFallbackProto.target)
    pub target: ::std::vec::Vec<TargetProto>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyFallbackProto.size_adjust_pct)
    pub size_adjust_pct: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyFallbackProto.ascent_override_pct)
    pub ascent_override_pct: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:google.fonts_public.FamilyFallbackProto.local_src)
    pub local_src: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.fonts_public.FamilyFallbackProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FamilyFallbackProto {
    fn default() -> &'a FamilyFallbackProto {
        <FamilyFallbackProto as ::protobuf::Message>::default_instance()
    }
}

impl FamilyFallbackProto {
    pub fn new() -> FamilyFallbackProto {
        ::std::default::Default::default()
    }

    // optional float size_adjust_pct = 3;

    pub fn size_adjust_pct(&self) -> f32 {
        self.size_adjust_pct.unwrap_or(0.)
    }

    pub fn clear_size_adjust_pct(&mut self) {
        self.size_adjust_pct = ::std::option::Option::None;
    }

    pub fn has_size_adjust_pct(&self) -> bool {
        self.size_adjust_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_adjust_pct(&mut self, v: f32) {
        self.size_adjust_pct = ::std::option::Option::Some(v);
    }

    // optional float ascent_override_pct = 5;

    pub fn ascent_override_pct(&self) -> f32 {
        self.ascent_override_pct.unwrap_or(0.)
    }

    pub fn clear_ascent_override_pct(&mut self) {
        self.ascent_override_pct = ::std::option::Option::None;
    }

    pub fn has_ascent_override_pct(&self) -> bool {
        self.ascent_override_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ascent_override_pct(&mut self, v: f32) {
        self.ascent_override_pct = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "axis_target",
            |m: &FamilyFallbackProto| { &m.axis_target },
            |m: &mut FamilyFallbackProto| { &mut m.axis_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "target",
            |m: &FamilyFallbackProto| { &m.target },
            |m: &mut FamilyFallbackProto| { &mut m.target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_adjust_pct",
            |m: &FamilyFallbackProto| { &m.size_adjust_pct },
            |m: &mut FamilyFallbackProto| { &mut m.size_adjust_pct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ascent_override_pct",
            |m: &FamilyFallbackProto| { &m.ascent_override_pct },
            |m: &mut FamilyFallbackProto| { &mut m.ascent_override_pct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "local_src",
            |m: &FamilyFallbackProto| { &m.local_src },
            |m: &mut FamilyFallbackProto| { &mut m.local_src },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FamilyFallbackProto>(
            "FamilyFallbackProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FamilyFallbackProto {
    const NAME: &'static str = "FamilyFallbackProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.axis_target.push(is.read_message()?);
                },
                18 => {
                    self.target.push(is.read_message()?);
                },
                29 => {
                    self.size_adjust_pct = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.ascent_override_pct = ::std::option::Option::Some(is.read_float()?);
                },
                34 => {
                    self.local_src.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.axis_target {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.target {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.size_adjust_pct {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ascent_override_pct {
            my_size += 1 + 4;
        }
        for value in &self.local_src {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.axis_target {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.target {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.size_adjust_pct {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.ascent_override_pct {
            os.write_float(5, v)?;
        }
        for v in &self.local_src {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FamilyFallbackProto {
        FamilyFallbackProto::new()
    }

    fn clear(&mut self) {
        self.axis_target.clear();
        self.target.clear();
        self.size_adjust_pct = ::std::option::Option::None;
        self.ascent_override_pct = ::std::option::Option::None;
        self.local_src.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FamilyFallbackProto {
        static instance: FamilyFallbackProto = FamilyFallbackProto {
            axis_target: ::std::vec::Vec::new(),
            target: ::std::vec::Vec::new(),
            size_adjust_pct: ::std::option::Option::None,
            ascent_override_pct: ::std::option::Option::None,
            local_src: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FamilyFallbackProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FamilyFallbackProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FamilyFallbackProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FamilyFallbackProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Corresponds to SampleTextProto in
///  google3/java/com/google/fonts/backend/spanner/google_fonts_proto.proto
// @@protoc_insertion_point(message:google.fonts_public.SampleTextProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SampleTextProto {
    // message fields
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.masthead_full)
    pub masthead_full: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.masthead_partial)
    pub masthead_partial: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.styles)
    pub styles: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.tester)
    pub tester: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.poster_sm)
    pub poster_sm: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.poster_md)
    pub poster_md: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.poster_lg)
    pub poster_lg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.specimen_48)
    pub specimen_48: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.specimen_36)
    pub specimen_36: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.specimen_32)
    pub specimen_32: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.specimen_21)
    pub specimen_21: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.specimen_16)
    pub specimen_16: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.SampleTextProto.note)
    pub note: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.fonts_public.SampleTextProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SampleTextProto {
    fn default() -> &'a SampleTextProto {
        <SampleTextProto as ::protobuf::Message>::default_instance()
    }
}

impl SampleTextProto {
    pub fn new() -> SampleTextProto {
        ::std::default::Default::default()
    }

    // optional string masthead_full = 1;

    pub fn masthead_full(&self) -> &str {
        match self.masthead_full.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_masthead_full(&mut self) {
        self.masthead_full = ::std::option::Option::None;
    }

    pub fn has_masthead_full(&self) -> bool {
        self.masthead_full.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masthead_full(&mut self, v: ::std::string::String) {
        self.masthead_full = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masthead_full(&mut self) -> &mut ::std::string::String {
        if self.masthead_full.is_none() {
            self.masthead_full = ::std::option::Option::Some(::std::string::String::new());
        }
        self.masthead_full.as_mut().unwrap()
    }

    // Take field
    pub fn take_masthead_full(&mut self) -> ::std::string::String {
        self.masthead_full.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string masthead_partial = 2;

    pub fn masthead_partial(&self) -> &str {
        match self.masthead_partial.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_masthead_partial(&mut self) {
        self.masthead_partial = ::std::option::Option::None;
    }

    pub fn has_masthead_partial(&self) -> bool {
        self.masthead_partial.is_some()
    }

    // Param is passed by value, moved
    pub fn set_masthead_partial(&mut self, v: ::std::string::String) {
        self.masthead_partial = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_masthead_partial(&mut self) -> &mut ::std::string::String {
        if self.masthead_partial.is_none() {
            self.masthead_partial = ::std::option::Option::Some(::std::string::String::new());
        }
        self.masthead_partial.as_mut().unwrap()
    }

    // Take field
    pub fn take_masthead_partial(&mut self) -> ::std::string::String {
        self.masthead_partial.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string styles = 3;

    pub fn styles(&self) -> &str {
        match self.styles.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_styles(&mut self) {
        self.styles = ::std::option::Option::None;
    }

    pub fn has_styles(&self) -> bool {
        self.styles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_styles(&mut self, v: ::std::string::String) {
        self.styles = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_styles(&mut self) -> &mut ::std::string::String {
        if self.styles.is_none() {
            self.styles = ::std::option::Option::Some(::std::string::String::new());
        }
        self.styles.as_mut().unwrap()
    }

    // Take field
    pub fn take_styles(&mut self) -> ::std::string::String {
        self.styles.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tester = 4;

    pub fn tester(&self) -> &str {
        match self.tester.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tester(&mut self) {
        self.tester = ::std::option::Option::None;
    }

    pub fn has_tester(&self) -> bool {
        self.tester.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tester(&mut self, v: ::std::string::String) {
        self.tester = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tester(&mut self) -> &mut ::std::string::String {
        if self.tester.is_none() {
            self.tester = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tester.as_mut().unwrap()
    }

    // Take field
    pub fn take_tester(&mut self) -> ::std::string::String {
        self.tester.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string poster_sm = 5;

    pub fn poster_sm(&self) -> &str {
        match self.poster_sm.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_poster_sm(&mut self) {
        self.poster_sm = ::std::option::Option::None;
    }

    pub fn has_poster_sm(&self) -> bool {
        self.poster_sm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poster_sm(&mut self, v: ::std::string::String) {
        self.poster_sm = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poster_sm(&mut self) -> &mut ::std::string::String {
        if self.poster_sm.is_none() {
            self.poster_sm = ::std::option::Option::Some(::std::string::String::new());
        }
        self.poster_sm.as_mut().unwrap()
    }

    // Take field
    pub fn take_poster_sm(&mut self) -> ::std::string::String {
        self.poster_sm.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string poster_md = 6;

    pub fn poster_md(&self) -> &str {
        match self.poster_md.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_poster_md(&mut self) {
        self.poster_md = ::std::option::Option::None;
    }

    pub fn has_poster_md(&self) -> bool {
        self.poster_md.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poster_md(&mut self, v: ::std::string::String) {
        self.poster_md = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poster_md(&mut self) -> &mut ::std::string::String {
        if self.poster_md.is_none() {
            self.poster_md = ::std::option::Option::Some(::std::string::String::new());
        }
        self.poster_md.as_mut().unwrap()
    }

    // Take field
    pub fn take_poster_md(&mut self) -> ::std::string::String {
        self.poster_md.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string poster_lg = 7;

    pub fn poster_lg(&self) -> &str {
        match self.poster_lg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_poster_lg(&mut self) {
        self.poster_lg = ::std::option::Option::None;
    }

    pub fn has_poster_lg(&self) -> bool {
        self.poster_lg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poster_lg(&mut self, v: ::std::string::String) {
        self.poster_lg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_poster_lg(&mut self) -> &mut ::std::string::String {
        if self.poster_lg.is_none() {
            self.poster_lg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.poster_lg.as_mut().unwrap()
    }

    // Take field
    pub fn take_poster_lg(&mut self) -> ::std::string::String {
        self.poster_lg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string specimen_48 = 8;

    pub fn specimen_48(&self) -> &str {
        match self.specimen_48.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_specimen_48(&mut self) {
        self.specimen_48 = ::std::option::Option::None;
    }

    pub fn has_specimen_48(&self) -> bool {
        self.specimen_48.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specimen_48(&mut self, v: ::std::string::String) {
        self.specimen_48 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_specimen_48(&mut self) -> &mut ::std::string::String {
        if self.specimen_48.is_none() {
            self.specimen_48 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.specimen_48.as_mut().unwrap()
    }

    // Take field
    pub fn take_specimen_48(&mut self) -> ::std::string::String {
        self.specimen_48.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string specimen_36 = 9;

    pub fn specimen_36(&self) -> &str {
        match self.specimen_36.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_specimen_36(&mut self) {
        self.specimen_36 = ::std::option::Option::None;
    }

    pub fn has_specimen_36(&self) -> bool {
        self.specimen_36.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specimen_36(&mut self, v: ::std::string::String) {
        self.specimen_36 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_specimen_36(&mut self) -> &mut ::std::string::String {
        if self.specimen_36.is_none() {
            self.specimen_36 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.specimen_36.as_mut().unwrap()
    }

    // Take field
    pub fn take_specimen_36(&mut self) -> ::std::string::String {
        self.specimen_36.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string specimen_32 = 10;

    pub fn specimen_32(&self) -> &str {
        match self.specimen_32.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_specimen_32(&mut self) {
        self.specimen_32 = ::std::option::Option::None;
    }

    pub fn has_specimen_32(&self) -> bool {
        self.specimen_32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specimen_32(&mut self, v: ::std::string::String) {
        self.specimen_32 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_specimen_32(&mut self) -> &mut ::std::string::String {
        if self.specimen_32.is_none() {
            self.specimen_32 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.specimen_32.as_mut().unwrap()
    }

    // Take field
    pub fn take_specimen_32(&mut self) -> ::std::string::String {
        self.specimen_32.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string specimen_21 = 11;

    pub fn specimen_21(&self) -> &str {
        match self.specimen_21.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_specimen_21(&mut self) {
        self.specimen_21 = ::std::option::Option::None;
    }

    pub fn has_specimen_21(&self) -> bool {
        self.specimen_21.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specimen_21(&mut self, v: ::std::string::String) {
        self.specimen_21 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_specimen_21(&mut self) -> &mut ::std::string::String {
        if self.specimen_21.is_none() {
            self.specimen_21 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.specimen_21.as_mut().unwrap()
    }

    // Take field
    pub fn take_specimen_21(&mut self) -> ::std::string::String {
        self.specimen_21.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string specimen_16 = 12;

    pub fn specimen_16(&self) -> &str {
        match self.specimen_16.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_specimen_16(&mut self) {
        self.specimen_16 = ::std::option::Option::None;
    }

    pub fn has_specimen_16(&self) -> bool {
        self.specimen_16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_specimen_16(&mut self, v: ::std::string::String) {
        self.specimen_16 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_specimen_16(&mut self) -> &mut ::std::string::String {
        if self.specimen_16.is_none() {
            self.specimen_16 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.specimen_16.as_mut().unwrap()
    }

    // Take field
    pub fn take_specimen_16(&mut self) -> ::std::string::String {
        self.specimen_16.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string note = 13;

    pub fn note(&self) -> &str {
        match self.note.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_note(&mut self) {
        self.note = ::std::option::Option::None;
    }

    pub fn has_note(&self) -> bool {
        self.note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_note(&mut self, v: ::std::string::String) {
        self.note = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_note(&mut self) -> &mut ::std::string::String {
        if self.note.is_none() {
            self.note = ::std::option::Option::Some(::std::string::String::new());
        }
        self.note.as_mut().unwrap()
    }

    // Take field
    pub fn take_note(&mut self) -> ::std::string::String {
        self.note.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "masthead_full",
            |m: &SampleTextProto| { &m.masthead_full },
            |m: &mut SampleTextProto| { &mut m.masthead_full },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "masthead_partial",
            |m: &SampleTextProto| { &m.masthead_partial },
            |m: &mut SampleTextProto| { &mut m.masthead_partial },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "styles",
            |m: &SampleTextProto| { &m.styles },
            |m: &mut SampleTextProto| { &mut m.styles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tester",
            |m: &SampleTextProto| { &m.tester },
            |m: &mut SampleTextProto| { &mut m.tester },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "poster_sm",
            |m: &SampleTextProto| { &m.poster_sm },
            |m: &mut SampleTextProto| { &mut m.poster_sm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "poster_md",
            |m: &SampleTextProto| { &m.poster_md },
            |m: &mut SampleTextProto| { &mut m.poster_md },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "poster_lg",
            |m: &SampleTextProto| { &m.poster_lg },
            |m: &mut SampleTextProto| { &mut m.poster_lg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "specimen_48",
            |m: &SampleTextProto| { &m.specimen_48 },
            |m: &mut SampleTextProto| { &mut m.specimen_48 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "specimen_36",
            |m: &SampleTextProto| { &m.specimen_36 },
            |m: &mut SampleTextProto| { &mut m.specimen_36 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "specimen_32",
            |m: &SampleTextProto| { &m.specimen_32 },
            |m: &mut SampleTextProto| { &mut m.specimen_32 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "specimen_21",
            |m: &SampleTextProto| { &m.specimen_21 },
            |m: &mut SampleTextProto| { &mut m.specimen_21 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "specimen_16",
            |m: &SampleTextProto| { &m.specimen_16 },
            |m: &mut SampleTextProto| { &mut m.specimen_16 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "note",
            |m: &SampleTextProto| { &m.note },
            |m: &mut SampleTextProto| { &mut m.note },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SampleTextProto>(
            "SampleTextProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SampleTextProto {
    const NAME: &'static str = "SampleTextProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.masthead_full = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.masthead_partial = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.styles = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.tester = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.poster_sm = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.poster_md = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.poster_lg = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.specimen_48 = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.specimen_36 = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.specimen_32 = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.specimen_21 = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.specimen_16 = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.note = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.masthead_full.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.masthead_partial.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.styles.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.tester.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.poster_sm.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.poster_md.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.poster_lg.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.specimen_48.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.specimen_36.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.specimen_32.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.specimen_21.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.specimen_16.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.note.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.masthead_full.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.masthead_partial.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.styles.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.tester.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.poster_sm.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.poster_md.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.poster_lg.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.specimen_48.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.specimen_36.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.specimen_32.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.specimen_21.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.specimen_16.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.note.as_ref() {
            os.write_string(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SampleTextProto {
        SampleTextProto::new()
    }

    fn clear(&mut self) {
        self.masthead_full = ::std::option::Option::None;
        self.masthead_partial = ::std::option::Option::None;
        self.styles = ::std::option::Option::None;
        self.tester = ::std::option::Option::None;
        self.poster_sm = ::std::option::Option::None;
        self.poster_md = ::std::option::Option::None;
        self.poster_lg = ::std::option::Option::None;
        self.specimen_48 = ::std::option::Option::None;
        self.specimen_36 = ::std::option::Option::None;
        self.specimen_32 = ::std::option::Option::None;
        self.specimen_21 = ::std::option::Option::None;
        self.specimen_16 = ::std::option::Option::None;
        self.note = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SampleTextProto {
        static instance: SampleTextProto = SampleTextProto {
            masthead_full: ::std::option::Option::None,
            masthead_partial: ::std::option::Option::None,
            styles: ::std::option::Option::None,
            tester: ::std::option::Option::None,
            poster_sm: ::std::option::Option::None,
            poster_md: ::std::option::Option::None,
            poster_lg: ::std::option::Option::None,
            specimen_48: ::std::option::Option::None,
            specimen_36: ::std::option::Option::None,
            specimen_32: ::std::option::Option::None,
            specimen_21: ::std::option::Option::None,
            specimen_16: ::std::option::Option::None,
            note: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SampleTextProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SampleTextProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SampleTextProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SampleTextProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.fonts_public.GlyphGroupProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GlyphGroupProto {
    // message fields
    // @@protoc_insertion_point(field:google.fonts_public.GlyphGroupProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.fonts_public.GlyphGroupProto.glyphs)
    pub glyphs: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.fonts_public.GlyphGroupProto.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GlyphGroupProto {
    fn default() -> &'a GlyphGroupProto {
        <GlyphGroupProto as ::protobuf::Message>::default_instance()
    }
}

impl GlyphGroupProto {
    pub fn new() -> GlyphGroupProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string glyphs = 2;

    pub fn glyphs(&self) -> &str {
        match self.glyphs.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_glyphs(&mut self) {
        self.glyphs = ::std::option::Option::None;
    }

    pub fn has_glyphs(&self) -> bool {
        self.glyphs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_glyphs(&mut self, v: ::std::string::String) {
        self.glyphs = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_glyphs(&mut self) -> &mut ::std::string::String {
        if self.glyphs.is_none() {
            self.glyphs = ::std::option::Option::Some(::std::string::String::new());
        }
        self.glyphs.as_mut().unwrap()
    }

    // Take field
    pub fn take_glyphs(&mut self) -> ::std::string::String {
        self.glyphs.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &GlyphGroupProto| { &m.name },
            |m: &mut GlyphGroupProto| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "glyphs",
            |m: &GlyphGroupProto| { &m.glyphs },
            |m: &mut GlyphGroupProto| { &mut m.glyphs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GlyphGroupProto>(
            "GlyphGroupProto",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GlyphGroupProto {
    const NAME: &'static str = "GlyphGroupProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.glyphs = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.glyphs.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.glyphs.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GlyphGroupProto {
        GlyphGroupProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.glyphs = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GlyphGroupProto {
        static instance: GlyphGroupProto = GlyphGroupProto {
            name: ::std::option::Option::None,
            glyphs: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GlyphGroupProto {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GlyphGroupProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GlyphGroupProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlyphGroupProto {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:google.fonts_public.TargetTypeProto)
pub enum TargetTypeProto {
    // @@protoc_insertion_point(enum_value:google.fonts_public.TargetTypeProto.TARGET_UNSPECIFIED)
    TARGET_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:google.fonts_public.TargetTypeProto.TARGET_OS_WINDOWS)
    TARGET_OS_WINDOWS = 1,
    // @@protoc_insertion_point(enum_value:google.fonts_public.TargetTypeProto.TARGET_OS_MAC)
    TARGET_OS_MAC = 2,
    // @@protoc_insertion_point(enum_value:google.fonts_public.TargetTypeProto.TARGET_OS_LINUX)
    TARGET_OS_LINUX = 3,
    // @@protoc_insertion_point(enum_value:google.fonts_public.TargetTypeProto.TARGET_OS_ANDROID)
    TARGET_OS_ANDROID = 4,
    // @@protoc_insertion_point(enum_value:google.fonts_public.TargetTypeProto.TARGET_OS_IOS)
    TARGET_OS_IOS = 5,
}

impl ::protobuf::Enum for TargetTypeProto {
    const NAME: &'static str = "TargetTypeProto";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TargetTypeProto> {
        match value {
            0 => ::std::option::Option::Some(TargetTypeProto::TARGET_UNSPECIFIED),
            1 => ::std::option::Option::Some(TargetTypeProto::TARGET_OS_WINDOWS),
            2 => ::std::option::Option::Some(TargetTypeProto::TARGET_OS_MAC),
            3 => ::std::option::Option::Some(TargetTypeProto::TARGET_OS_LINUX),
            4 => ::std::option::Option::Some(TargetTypeProto::TARGET_OS_ANDROID),
            5 => ::std::option::Option::Some(TargetTypeProto::TARGET_OS_IOS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TargetTypeProto> {
        match str {
            "TARGET_UNSPECIFIED" => ::std::option::Option::Some(TargetTypeProto::TARGET_UNSPECIFIED),
            "TARGET_OS_WINDOWS" => ::std::option::Option::Some(TargetTypeProto::TARGET_OS_WINDOWS),
            "TARGET_OS_MAC" => ::std::option::Option::Some(TargetTypeProto::TARGET_OS_MAC),
            "TARGET_OS_LINUX" => ::std::option::Option::Some(TargetTypeProto::TARGET_OS_LINUX),
            "TARGET_OS_ANDROID" => ::std::option::Option::Some(TargetTypeProto::TARGET_OS_ANDROID),
            "TARGET_OS_IOS" => ::std::option::Option::Some(TargetTypeProto::TARGET_OS_IOS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TargetTypeProto] = &[
        TargetTypeProto::TARGET_UNSPECIFIED,
        TargetTypeProto::TARGET_OS_WINDOWS,
        TargetTypeProto::TARGET_OS_MAC,
        TargetTypeProto::TARGET_OS_LINUX,
        TargetTypeProto::TARGET_OS_ANDROID,
        TargetTypeProto::TARGET_OS_IOS,
    ];
}

impl ::protobuf::EnumFull for TargetTypeProto {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TargetTypeProto").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TargetTypeProto {
    fn default() -> Self {
        TargetTypeProto::TARGET_UNSPECIFIED
    }
}

impl TargetTypeProto {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TargetTypeProto>("TargetTypeProto")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12fonts_public.proto\x12\x13google.fonts_public\"\xfc\t\n\x0bFamilyP\
    roto\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\x1a\n\x08designer\
    \x18\x02\x20\x02(\tR\x08designer\x12\x18\n\x07license\x18\x03\x20\x02(\t\
    R\x07license\x12\x1a\n\x08category\x18\x04\x20\x03(\tR\x08category\x12\
    \x1d\n\ndate_added\x18\x05\x20\x02(\tR\tdateAdded\x124\n\x05fonts\x18\
    \x06\x20\x03(\x0b2\x1e.google.fonts_public.FontProtoR\x05fonts\x12\x18\n\
    \x07aliases\x18\x07\x20\x03(\tR\x07aliases\x12\x18\n\x07subsets\x18\x08\
    \x20\x03(\tR\x07subsets\x12*\n\x11ttf_autohint_args\x18\t\x20\x01(\tR\
    \x0fttfAutohintArgs\x129\n\x04axes\x18\n\x20\x03(\x0b2%.google.fonts_pub\
    lic.AxisSegmentProtoR\x04axes\x12|\n\x1aregistry_default_overrides\x18\
    \x0b\x20\x03(\x0b2>.google.fonts_public.FamilyProto.RegistryDefaultOverr\
    idesEntryR\x18registryDefaultOverrides\x128\n\x06source\x18\x0c\x20\x01(\
    \x0b2\x20.google.fonts_public.SourceProtoR\x06source\x12\x17\n\x07is_not\
    o\x18\r\x20\x01(\x08R\x06isNoto\x12\x1c\n\tlanguages\x18\x0e\x20\x03(\tR\
    \tlanguages\x12F\n\tfallbacks\x18\x0f\x20\x03(\x0b2(.google.fonts_public\
    .FamilyFallbackProtoR\tfallbacks\x12W\n\rsample_glyphs\x18\x10\x20\x03(\
    \x0b22.google.fonts_public.FamilyProto.SampleGlyphsEntryR\x0csampleGlyph\
    s\x12E\n\x0bsample_text\x18\x11\x20\x01(\x0b2$.google.fonts_public.Sampl\
    eTextProtoR\nsampleText\x12!\n\x0cdisplay_name\x18\x12\x20\x01(\tR\x0bdi\
    splayName\x12X\n\x15ordered_sample_glyphs\x18\x13\x20\x03(\x0b2$.google.\
    fonts_public.GlyphGroupProtoR\x13orderedSampleGlyphs\x12!\n\x0cminisite_\
    url\x18\x14\x20\x01(\tR\x0bminisiteUrl\x12%\n\x0eprimary_script\x18\x15\
    \x20\x01(\tR\rprimaryScript\x12)\n\x10primary_language\x18\x16\x20\x01(\
    \tR\x0fprimaryLanguage\x12\x16\n\x06stroke\x18\x17\x20\x01(\tR\x06stroke\
    \x12(\n\x0fclassifications\x18\x19\x20\x03(\tR\x0fclassifications\x1aK\n\
    \x1dRegistryDefaultOverridesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05value:\x028\x01\x1a?\
    \n\x11SampleGlyphsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xce\x01\n\tFont\
    Proto\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\x14\n\x05style\
    \x18\x02\x20\x02(\tR\x05style\x12\x16\n\x06weight\x18\x03\x20\x02(\x05R\
    \x06weight\x12\x1a\n\x08filename\x18\x04\x20\x02(\tR\x08filename\x12(\n\
    \x10post_script_name\x18\x05\x20\x02(\tR\x0epostScriptName\x12\x1b\n\tfu\
    ll_name\x18\x06\x20\x02(\tR\x08fullName\x12\x1c\n\tcopyright\x18\x07\x20\
    \x01(\tR\tcopyright\"s\n\x10AxisSegmentProto\x12\x10\n\x03tag\x18\x01\
    \x20\x01(\tR\x03tag\x12\x1b\n\tmin_value\x18\x02\x20\x01(\x02R\x08minVal\
    ue\x12\x1b\n\tmax_value\x18\x04\x20\x01(\x02R\x08maxValueJ\x04\x08\x03\
    \x10\x04R\rdefault_value\"\xe2\x01\n\x0bSourceProto\x12%\n\x0erepository\
    _url\x18\x01\x20\x01(\tR\rrepositoryUrl\x12\x16\n\x06branch\x18\x05\x20\
    \x01(\tR\x06branch\x12\x16\n\x06commit\x18\x02\x20\x01(\tR\x06commit\x12\
    \x1f\n\x0barchive_url\x18\x03\x20\x01(\tR\narchiveUrl\x12\x1f\n\x0bconfi\
    g_yaml\x18\x06\x20\x01(\tR\nconfigYaml\x12:\n\x05files\x18\x04\x20\x03(\
    \x0b2$.google.fonts_public.SourceFileProtoR\x05files\"O\n\x0fSourceFileP\
    roto\x12\x1f\n\x0bsource_file\x18\x01\x20\x01(\tR\nsourceFile\x12\x1b\n\
    \tdest_file\x18\x02\x20\x01(\tR\x08destFile\"T\n\x0bTargetProto\x12E\n\
    \x0btarget_type\x18\x01\x20\x01(\x0e2$.google.fonts_public.TargetTypePro\
    toR\ntargetType\"\x8c\x02\n\x13FamilyFallbackProto\x12F\n\x0baxis_target\
    \x18\x01\x20\x03(\x0b2%.google.fonts_public.AxisSegmentProtoR\naxisTarge\
    t\x128\n\x06target\x18\x02\x20\x03(\x0b2\x20.google.fonts_public.TargetP\
    rotoR\x06target\x12&\n\x0fsize_adjust_pct\x18\x03\x20\x01(\x02R\rsizeAdj\
    ustPct\x12.\n\x13ascent_override_pct\x18\x05\x20\x01(\x02R\x11ascentOver\
    ridePct\x12\x1b\n\tlocal_src\x18\x04\x20\x03(\tR\x08localSrc\"\xa1\x03\n\
    \x0fSampleTextProto\x12#\n\rmasthead_full\x18\x01\x20\x01(\tR\x0cmasthea\
    dFull\x12)\n\x10masthead_partial\x18\x02\x20\x01(\tR\x0fmastheadPartial\
    \x12\x16\n\x06styles\x18\x03\x20\x01(\tR\x06styles\x12\x16\n\x06tester\
    \x18\x04\x20\x01(\tR\x06tester\x12\x1b\n\tposter_sm\x18\x05\x20\x01(\tR\
    \x08posterSm\x12\x1b\n\tposter_md\x18\x06\x20\x01(\tR\x08posterMd\x12\
    \x1b\n\tposter_lg\x18\x07\x20\x01(\tR\x08posterLg\x12\x1f\n\x0bspecimen_\
    48\x18\x08\x20\x01(\tR\nspecimen48\x12\x1f\n\x0bspecimen_36\x18\t\x20\
    \x01(\tR\nspecimen36\x12\x1f\n\x0bspecimen_32\x18\n\x20\x01(\tR\nspecime\
    n32\x12\x1f\n\x0bspecimen_21\x18\x0b\x20\x01(\tR\nspecimen21\x12\x1f\n\
    \x0bspecimen_16\x18\x0c\x20\x01(\tR\nspecimen16\x12\x12\n\x04note\x18\r\
    \x20\x01(\tR\x04note\"=\n\x0fGlyphGroupProto\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x16\n\x06glyphs\x18\x02\x20\x01(\tR\x06glyphs*\
    \x92\x01\n\x0fTargetTypeProto\x12\x16\n\x12TARGET_UNSPECIFIED\x10\0\x12\
    \x15\n\x11TARGET_OS_WINDOWS\x10\x01\x12\x11\n\rTARGET_OS_MAC\x10\x02\x12\
    \x13\n\x0fTARGET_OS_LINUX\x10\x03\x12\x15\n\x11TARGET_OS_ANDROID\x10\x04\
    \x12\x11\n\rTARGET_OS_IOS\x10\x05B%\n\x16com.google.fonts.protoB\x0bFont\
    sPublicJ\xe63\n\x07\x12\x05\0\0\x8e\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\
    \x12\n8\n\x01\x02\x12\x03\x05\0\x1c\x1a.*\n\x20Open\x20Source'd\x20font\
    \x20metadata\x20proto\x20formats.\n\n\x08\n\x01\x08\x12\x03\x07\0/\n\t\n\
    \x02\x08\x01\x12\x03\x07\0/\n\x08\n\x01\x08\x12\x03\x08\0,\n\t\n\x02\x08\
    \x08\x12\x03\x08\0,\n\n\n\x02\x04\0\x12\x04\n\0:\x01\n\n\n\x03\x04\0\x01\
    \x12\x03\n\x08\x13\n\x0b\n\x04\x04\0\x02\0\x12\x03\x0b\x02\x1b\n\x0c\n\
    \x05\x04\0\x02\0\x04\x12\x03\x0b\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\
    \x03\x0b\x0b\x11\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x0b\x12\x16\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03\x0b\x19\x1a\n\x0b\n\x04\x04\0\x02\x01\x12\
    \x03\x0c\x02\x1f\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x0c\x02\n\n\x0c\n\
    \x05\x04\0\x02\x01\x05\x12\x03\x0c\x0b\x11\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03\x0c\x12\x1a\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x0c\x1d\x1e\n\
    \x0b\n\x04\x04\0\x02\x02\x12\x03\r\x02\x1e\n\x0c\n\x05\x04\0\x02\x02\x04\
    \x12\x03\r\x02\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\r\x0b\x11\n\x0c\n\
    \x05\x04\0\x02\x02\x01\x12\x03\r\x12\x19\n\x0c\n\x05\x04\0\x02\x02\x03\
    \x12\x03\r\x1c\x1d\n\x83\x05\n\x04\x04\0\x02\x03\x12\x03\x1a\x02\x1f\x1a\
    \xc6\x04\x20A\x20mutually-exclusive\x20category\x20for\x20each\x20font.\
    \x20The\x20categories\x20are:\x20Serif,\n\x20Sans\x20Serif,\x20Display,\
    \x20Handwriting\x20and\x20Monospace.\x20Being\x20mutually\x20exclusive\
    \x20is\n\x20a\x20significant\x20deficiency\x20as,\x20for\x20example,\x20\
    most\x20Display\x20fonts\x20are\x20typically\n\x20Serif\x20or\x20Sans\
    \x20Serif\x20and\x20that\x20is\x20not\x20captured.\n\n\x20For\x20searchi\
    ng,\x20this\x20field\x20is\x20replaced\x20by\x20stroke\x20and\x20classif\
    ications\x20(see\n\x20below),\x20however,\x20this\x20field\x20persists\
    \x20(it's\x20required\x20after\x20all)\x20and\x20will\n\x20continue\x20t\
    o\x20be\x20populated\x20in\x20the\x20onboarding\x20process.\n\n\x20This\
    \x20is\x20repeated\x20field,\x20yet\x20Google\x20Fonts\x20only\x20uses\
    \x20the\x20last\x20entry\x20so\n\x20multiple\x20entries\x20should\x20be\
    \x20avoided.\n\"-\x20Only\x20the\x20LAST\x20value\x20is\x20used\x20by\
    \x20Google\x20Fonts\n\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x1a\x02\n\n\
    \x0c\n\x05\x04\0\x02\x03\x05\x12\x03\x1a\x0b\x11\n\x0c\n\x05\x04\0\x02\
    \x03\x01\x12\x03\x1a\x12\x1a\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x1a\
    \x1d\x1e\n\x0b\n\x04\x04\0\x02\x04\x12\x03\x1b\x02!\n\x0c\n\x05\x04\0\
    \x02\x04\x04\x12\x03\x1b\x02\n\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x1b\
    \x0b\x11\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x1b\x12\x1c\n\x0c\n\x05\
    \x04\0\x02\x04\x03\x12\x03\x1b\x1f\x20\n\x0b\n\x04\x04\0\x02\x05\x12\x03\
    \x1c\x02\x1f\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\x1c\x02\n\n\x0c\n\x05\
    \x04\0\x02\x05\x06\x12\x03\x1c\x0b\x14\n\x0c\n\x05\x04\0\x02\x05\x01\x12\
    \x03\x1c\x15\x1a\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x1c\x1d\x1e\n\x0b\
    \n\x04\x04\0\x02\x06\x12\x03\x1d\x02\x1e\n\x0c\n\x05\x04\0\x02\x06\x04\
    \x12\x03\x1d\x02\n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x1d\x0b\x11\n\
    \x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x1d\x12\x19\n\x0c\n\x05\x04\0\x02\
    \x06\x03\x12\x03\x1d\x1c\x1d\n\x0b\n\x04\x04\0\x02\x07\x12\x03\x1e\x02\
    \x1e\n\x0c\n\x05\x04\0\x02\x07\x04\x12\x03\x1e\x02\n\n\x0c\n\x05\x04\0\
    \x02\x07\x05\x12\x03\x1e\x0b\x11\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\
    \x1e\x12\x19\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03\x1e\x1c\x1d\n\x0b\n\
    \x04\x04\0\x02\x08\x12\x03\x1f\x02(\n\x0c\n\x05\x04\0\x02\x08\x04\x12\
    \x03\x1f\x02\n\n\x0c\n\x05\x04\0\x02\x08\x05\x12\x03\x1f\x0b\x11\n\x0c\n\
    \x05\x04\0\x02\x08\x01\x12\x03\x1f\x12#\n\x0c\n\x05\x04\0\x02\x08\x03\
    \x12\x03\x1f&'\n\x0b\n\x04\x04\0\x02\t\x12\x03\x20\x02&\n\x0c\n\x05\x04\
    \0\x02\t\x04\x12\x03\x20\x02\n\n\x0c\n\x05\x04\0\x02\t\x06\x12\x03\x20\
    \x0b\x1b\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03\x20\x1c\x20\n\x0c\n\x05\x04\
    \0\x02\t\x03\x12\x03\x20#%\n\x0b\n\x04\x04\0\x02\n\x12\x03!\x025\n\x0c\n\
    \x05\x04\0\x02\n\x06\x12\x03!\x02\x14\n\x0c\n\x05\x04\0\x02\n\x01\x12\
    \x03!\x15/\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03!24\n\x0b\n\x04\x04\0\x02\
    \x0b\x12\x03\"\x02#\n\x0c\n\x05\x04\0\x02\x0b\x04\x12\x03\"\x02\n\n\x0c\
    \n\x05\x04\0\x02\x0b\x06\x12\x03\"\x0b\x16\n\x0c\n\x05\x04\0\x02\x0b\x01\
    \x12\x03\"\x17\x1d\n\x0c\n\x05\x04\0\x02\x0b\x03\x12\x03\"\x20\"\n\x0b\n\
    \x04\x04\0\x02\x0c\x12\x03#\x02\x1d\n\x0c\n\x05\x04\0\x02\x0c\x04\x12\
    \x03#\x02\n\n\x0c\n\x05\x04\0\x02\x0c\x05\x12\x03#\x0b\x0f\n\x0c\n\x05\
    \x04\0\x02\x0c\x01\x12\x03#\x10\x17\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\
    \x03#\x1a\x1c\n\x0b\n\x04\x04\0\x02\r\x12\x03$\x02!\n\x0c\n\x05\x04\0\
    \x02\r\x04\x12\x03$\x02\n\n\x0c\n\x05\x04\0\x02\r\x05\x12\x03$\x0b\x11\n\
    \x0c\n\x05\x04\0\x02\r\x01\x12\x03$\x12\x1b\n\x0c\n\x05\x04\0\x02\r\x03\
    \x12\x03$\x1e\x20\n\x0b\n\x04\x04\0\x02\x0e\x12\x03%\x02.\n\x0c\n\x05\
    \x04\0\x02\x0e\x04\x12\x03%\x02\n\n\x0c\n\x05\x04\0\x02\x0e\x06\x12\x03%\
    \x0b\x1e\n\x0c\n\x05\x04\0\x02\x0e\x01\x12\x03%\x1f(\n\x0c\n\x05\x04\0\
    \x02\x0e\x03\x12\x03%+-\n\x0b\n\x04\x04\0\x02\x0f\x12\x03&\x02)\n\x0c\n\
    \x05\x04\0\x02\x0f\x06\x12\x03&\x02\x15\n\x0c\n\x05\x04\0\x02\x0f\x01\
    \x12\x03&\x16#\n\x0c\n\x05\x04\0\x02\x0f\x03\x12\x03&&(\n\x0b\n\x04\x04\
    \0\x02\x10\x12\x03'\x02,\n\x0c\n\x05\x04\0\x02\x10\x04\x12\x03'\x02\n\n\
    \x0c\n\x05\x04\0\x02\x10\x06\x12\x03'\x0b\x1a\n\x0c\n\x05\x04\0\x02\x10\
    \x01\x12\x03'\x1b&\n\x0c\n\x05\x04\0\x02\x10\x03\x12\x03')+\n\x0b\n\x04\
    \x04\0\x02\x11\x12\x03(\x02$\n\x0c\n\x05\x04\0\x02\x11\x04\x12\x03(\x02\
    \n\n\x0c\n\x05\x04\0\x02\x11\x05\x12\x03(\x0b\x11\n\x0c\n\x05\x04\0\x02\
    \x11\x01\x12\x03(\x12\x1e\n\x0c\n\x05\x04\0\x02\x11\x03\x12\x03(!#\n\x0b\
    \n\x04\x04\0\x02\x12\x12\x03)\x026\n\x0c\n\x05\x04\0\x02\x12\x04\x12\x03\
    )\x02\n\n\x0c\n\x05\x04\0\x02\x12\x06\x12\x03)\x0b\x1a\n\x0c\n\x05\x04\0\
    \x02\x12\x01\x12\x03)\x1b0\n\x0c\n\x05\x04\0\x02\x12\x03\x12\x03)35\n9\n\
    \x04\x04\0\x02\x13\x12\x03+\x02$\x1a,\x20Optional\x20url\x20for\x20more\
    \x20info\x20about\x20the\x20font.\n\n\x0c\n\x05\x04\0\x02\x13\x04\x12\
    \x03+\x02\n\n\x0c\n\x05\x04\0\x02\x13\x05\x12\x03+\x0b\x11\n\x0c\n\x05\
    \x04\0\x02\x13\x01\x12\x03+\x12\x1e\n\x0c\n\x05\x04\0\x02\x13\x03\x12\
    \x03+!#\nX\n\x04\x04\0\x02\x14\x12\x03-\x02&\x1aK\x20The\x20script\x20to\
    \x20use\x20when\x20picking\x20sample\x20text.\x20See\x20the\x20Script\
    \x20spanner\x20table.\n\n\x0c\n\x05\x04\0\x02\x14\x04\x12\x03-\x02\n\n\
    \x0c\n\x05\x04\0\x02\x14\x05\x12\x03-\x0b\x11\n\x0c\n\x05\x04\0\x02\x14\
    \x01\x12\x03-\x12\x20\n\x0c\n\x05\x04\0\x02\x14\x03\x12\x03-#%\n\x0b\n\
    \x04\x04\0\x02\x15\x12\x03/\x02(\n\x0c\n\x05\x04\0\x02\x15\x04\x12\x03/\
    \x02\n\n\x0c\n\x05\x04\0\x02\x15\x05\x12\x03/\x0b\x11\n\x0c\n\x05\x04\0\
    \x02\x15\x01\x12\x03/\x12\"\n\x0c\n\x05\x04\0\x02\x15\x03\x12\x03/%'\n\
    \xad\x01\n\x04\x04\0\x02\x16\x12\x034\x02\x1e\x1a\x9f\x01\x20Stroke\x20o\
    f\x20the\x20letter\x20forms:\x20serif,\x20sans\x20serif,\x20etc.\x20Stro\
    ke\x20is\x20mutually\n\x20exclusive.\x20The\x20values\x20are\x20the\x20s\
    tring\x20names\x20from\x20the\x20Stroke\x20enum\x20or\x20the\n\x20empty\
    \x20string.\n\n\x0c\n\x05\x04\0\x02\x16\x04\x12\x034\x02\n\n\x0c\n\x05\
    \x04\0\x02\x16\x05\x12\x034\x0b\x11\n\x0c\n\x05\x04\0\x02\x16\x01\x12\
    \x034\x12\x18\n\x0c\n\x05\x04\0\x02\x16\x03\x12\x034\x1b\x1d\n\xa3\x01\n\
    \x04\x04\0\x02\x17\x12\x038\x02'\x1a\x88\x01\x20A\x20family's\x20broad\
    \x20classifications:\x20display,\x20handwriting,\x20monospace,\x20etc.\n\
    \x20The\x20values\x20are\x20the\x20string\x20names\x20from\x20the\x20Cla\
    ssification\x20enum.\n\"\x0b\x20Next\x20=\x2025\n\n\x0c\n\x05\x04\0\x02\
    \x17\x04\x12\x038\x02\n\n\x0c\n\x05\x04\0\x02\x17\x05\x12\x038\x0b\x11\n\
    \x0c\n\x05\x04\0\x02\x17\x01\x12\x038\x12!\n\x0c\n\x05\x04\0\x02\x17\x03\
    \x12\x038$&\n\n\n\x02\x04\x01\x12\x04<\0D\x01\n\n\n\x03\x04\x01\x01\x12\
    \x03<\x08\x11\n\x0b\n\x04\x04\x01\x02\0\x12\x03=\x02\x1b\n\x0c\n\x05\x04\
    \x01\x02\0\x04\x12\x03=\x02\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03=\x0b\
    \x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03=\x12\x16\n\x0c\n\x05\x04\x01\
    \x02\0\x03\x12\x03=\x19\x1a\n\x0b\n\x04\x04\x01\x02\x01\x12\x03>\x02\x1c\
    \n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03>\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x01\x05\x12\x03>\x0b\x11\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03>\x12\
    \x17\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03>\x1a\x1b\n\x0b\n\x04\x04\
    \x01\x02\x02\x12\x03?\x02\x1c\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03?\
    \x02\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03?\x0b\x10\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03?\x11\x17\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\
    \x03?\x1a\x1b\n\x0b\n\x04\x04\x01\x02\x03\x12\x03@\x02\x1f\n\x0c\n\x05\
    \x04\x01\x02\x03\x04\x12\x03@\x02\n\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\
    \x03@\x0b\x11\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03@\x12\x1a\n\x0c\n\
    \x05\x04\x01\x02\x03\x03\x12\x03@\x1d\x1e\n\x0b\n\x04\x04\x01\x02\x04\
    \x12\x03A\x02'\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03A\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x04\x05\x12\x03A\x0b\x11\n\x0c\n\x05\x04\x01\x02\x04\
    \x01\x12\x03A\x12\"\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03A%&\n\x0b\n\
    \x04\x04\x01\x02\x05\x12\x03B\x02\x20\n\x0c\n\x05\x04\x01\x02\x05\x04\
    \x12\x03B\x02\n\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03B\x0b\x11\n\x0c\n\
    \x05\x04\x01\x02\x05\x01\x12\x03B\x12\x1b\n\x0c\n\x05\x04\x01\x02\x05\
    \x03\x12\x03B\x1e\x1f\n\x0b\n\x04\x04\x01\x02\x06\x12\x03C\x02\x20\n\x0c\
    \n\x05\x04\x01\x02\x06\x04\x12\x03C\x02\n\n\x0c\n\x05\x04\x01\x02\x06\
    \x05\x12\x03C\x0b\x11\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03C\x12\x1b\n\
    \x0c\n\x05\x04\x01\x02\x06\x03\x12\x03C\x1e\x1f\n\n\n\x02\x04\x02\x12\
    \x04F\0M\x01\n\n\n\x03\x04\x02\x01\x12\x03F\x08\x18\n\x0b\n\x04\x04\x02\
    \x02\0\x12\x03G\x02\x1a\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03G\x02\n\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03G\x0b\x11\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03G\x12\x15\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03G\x18\x19\n\
    \x0b\n\x04\x04\x02\x02\x01\x12\x03H\x02\x1f\n\x0c\n\x05\x04\x02\x02\x01\
    \x04\x12\x03H\x02\n\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03H\x0b\x10\n\
    \x0c\n\x05\x04\x02\x02\x01\x01\x12\x03H\x11\x1a\n\x0c\n\x05\x04\x02\x02\
    \x01\x03\x12\x03H\x1d\x1e\n\n\n\x03\x04\x02\t\x12\x03I\x02\r\n\x0b\n\x04\
    \x04\x02\t\0\x12\x03I\x0b\x0c\n\x0c\n\x05\x04\x02\t\0\x01\x12\x03I\x0b\
    \x0c\n\x0c\n\x05\x04\x02\t\0\x02\x12\x03I\x0b\x0c\n\n\n\x03\x04\x02\n\
    \x12\x03J\x02\x1b\n\x0b\n\x04\x04\x02\n\0\x12\x03J\x0b\x1a\n\x17\n\x04\
    \x04\x02\x02\x02\x12\x03K\x02\x1f\"\n\x20Next\x20=\x205\n\n\x0c\n\x05\
    \x04\x02\x02\x02\x04\x12\x03K\x02\n\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\
    \x03K\x0b\x10\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03K\x11\x1a\n\x0c\n\
    \x05\x04\x02\x02\x02\x03\x12\x03K\x1d\x1e\n\n\n\x02\x04\x03\x12\x04O\0Y\
    \x01\n\n\n\x03\x04\x03\x01\x12\x03O\x08\x13\n\x0b\n\x04\x04\x03\x02\0\
    \x12\x03P\x02%\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03P\x02\n\n\x0c\n\x05\
    \x04\x03\x02\0\x05\x12\x03P\x0b\x11\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03P\x12\x20\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03P#$\n\x0b\n\x04\x04\
    \x03\x02\x01\x12\x03Q\x02\x1d\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03Q\
    \x02\n\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03Q\x0b\x11\n\x0c\n\x05\x04\
    \x03\x02\x01\x01\x12\x03Q\x12\x18\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\
    \x03Q\x1b\x1c\n\x0b\n\x04\x04\x03\x02\x02\x12\x03R\x02\x1d\n\x0c\n\x05\
    \x04\x03\x02\x02\x04\x12\x03R\x02\n\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\
    \x03R\x0b\x11\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03R\x12\x18\n\x0c\n\
    \x05\x04\x03\x02\x02\x03\x12\x03R\x1b\x1c\n\x0b\n\x04\x04\x03\x02\x03\
    \x12\x03S\x02\"\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03S\x02\n\n\x0c\n\
    \x05\x04\x03\x02\x03\x05\x12\x03S\x0b\x11\n\x0c\n\x05\x04\x03\x02\x03\
    \x01\x12\x03S\x12\x1d\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03S\x20!\nD\n\
    \x04\x04\x03\x02\x04\x12\x04T\x02U\x08\"6\x20See\x20https://github.com/g\
    ooglefonts/fontc/issues/1124\n\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03T\
    \x02\n\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03T\x0b\x11\n\x0c\n\x05\x04\
    \x03\x02\x04\x01\x12\x03T\x12\x1d\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\
    \x03U\x06\x07\n\x0b\n\x04\x04\x03\x02\x05\x12\x03V\x02%\n\x0c\n\x05\x04\
    \x03\x02\x05\x04\x12\x03V\x02\n\n\x0c\n\x05\x04\x03\x02\x05\x06\x12\x03V\
    \x0b\x1a\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03V\x1b\x20\n\x0c\n\x05\
    \x04\x03\x02\x05\x03\x12\x03V#$\n\x81\x01\n\x02\x04\x04\x12\x04]\0`\x01\
    \x1au\x20A\x20file\x20to\x20take\x20from\x20source\x20and\x20where\x20to\
    \x20put\x20it\x20in\x20dest\n\x20Ex\x20web/split/Roboto[wdth,wght].ttf\
    \x20=>\x20Roboto[wdth,wght].ttf\n\n\n\n\x03\x04\x04\x01\x12\x03]\x08\x17\
    \n\x0b\n\x04\x04\x04\x02\0\x12\x03^\x02\"\n\x0c\n\x05\x04\x04\x02\0\x04\
    \x12\x03^\x02\n\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03^\x0b\x11\n\x0c\n\
    \x05\x04\x04\x02\0\x01\x12\x03^\x12\x1d\n\x0c\n\x05\x04\x04\x02\0\x03\
    \x12\x03^\x20!\n\x0b\n\x04\x04\x04\x02\x01\x12\x03_\x02\x20\n\x0c\n\x05\
    \x04\x04\x02\x01\x04\x12\x03_\x02\n\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\
    \x03_\x0b\x11\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03_\x12\x1b\n\x0c\n\
    \x05\x04\x04\x02\x01\x03\x12\x03_\x1e\x1f\n\n\n\x02\x05\0\x12\x04b\0i\
    \x01\n\n\n\x03\x05\0\x01\x12\x03b\x05\x14\n\x0b\n\x04\x05\0\x02\0\x12\
    \x03c\x02\x19\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03c\x02\x14\n\x0c\n\x05\
    \x05\0\x02\0\x02\x12\x03c\x17\x18\n\x0b\n\x04\x05\0\x02\x01\x12\x03d\x02\
    \x18\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03d\x02\x13\n\x0c\n\x05\x05\0\
    \x02\x01\x02\x12\x03d\x16\x17\n\x0b\n\x04\x05\0\x02\x02\x12\x03e\x02\x14\
    \n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03e\x02\x0f\n\x0c\n\x05\x05\0\x02\
    \x02\x02\x12\x03e\x12\x13\n\x0b\n\x04\x05\0\x02\x03\x12\x03f\x02\x16\n\
    \x0c\n\x05\x05\0\x02\x03\x01\x12\x03f\x02\x11\n\x0c\n\x05\x05\0\x02\x03\
    \x02\x12\x03f\x14\x15\n\x0b\n\x04\x05\0\x02\x04\x12\x03g\x02\x18\n\x0c\n\
    \x05\x05\0\x02\x04\x01\x12\x03g\x02\x13\n\x0c\n\x05\x05\0\x02\x04\x02\
    \x12\x03g\x16\x17\n\x0b\n\x04\x05\0\x02\x05\x12\x03h\x02\x14\n\x0c\n\x05\
    \x05\0\x02\x05\x01\x12\x03h\x02\x0f\n\x0c\n\x05\x05\0\x02\x05\x02\x12\
    \x03h\x12\x13\nJ\n\x02\x04\x05\x12\x04l\0n\x01\x1a>\x20Message\x20so\x20\
    we\x20can\x20add\x20additional\x20fields\x20like\x20value\x20in\x20futur\
    e\n\n\n\n\x03\x04\x05\x01\x12\x03l\x08\x13\n\x18\n\x04\x04\x05\x02\0\x12\
    \x03m\x02+\"\x0b\x20\x20e.g.,\x20OS\n\n\x0c\n\x05\x04\x05\x02\0\x04\x12\
    \x03m\x02\n\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03m\x0b\x1a\n\x0c\n\x05\
    \x04\x05\x02\0\x01\x12\x03m\x1b&\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03m)\
    *\n\n\n\x02\x04\x06\x12\x04p\0w\x01\n\n\n\x03\x04\x06\x01\x12\x03p\x08\
    \x1b\n'\n\x04\x04\x06\x02\0\x12\x03q\x02,\"\x1a\x20activate\x20for\x20th\
    is\x20region\n\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03q\x02\n\n\x0c\n\x05\
    \x04\x06\x02\0\x06\x12\x03q\x0b\x1b\n\x0c\n\x05\x04\x06\x02\0\x01\x12\
    \x03q\x1c'\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03q*+\n(\n\x04\x04\x06\x02\
    \x01\x12\x03r\x02\"\"\x1b\x20activate\x20for\x20any\x20of\x20these\n\n\
    \x0c\n\x05\x04\x06\x02\x01\x04\x12\x03r\x02\n\n\x0c\n\x05\x04\x06\x02\
    \x01\x06\x12\x03r\x0b\x16\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\x03r\x17\
    \x1d\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03r\x20!\n\x17\n\x04\x04\x06\
    \x02\x02\x12\x03s\x02%\"\n\x20e.g.\x2090%\n\n\x0c\n\x05\x04\x06\x02\x02\
    \x04\x12\x03s\x02\n\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03s\x0b\x10\n\
    \x0c\n\x05\x04\x06\x02\x02\x01\x12\x03s\x11\x20\n\x0c\n\x05\x04\x06\x02\
    \x02\x03\x12\x03s#$\n\x18\n\x04\x04\x06\x02\x03\x12\x03t\x02)\"\x0b\x20e\
    .g.\x20110%\n\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03t\x02\n\n\x0c\n\x05\
    \x04\x06\x02\x03\x05\x12\x03t\x0b\x10\n\x0c\n\x05\x04\x06\x02\x03\x01\
    \x12\x03t\x11$\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03t'(\n3\n\x04\x04\
    \x06\x02\x04\x12\x03u\x02\x20\"&\x20e.g.\x20Impact;\x20the\x20local\x20f\
    amily\x20to\x20use\n\n\x0c\n\x05\x04\x06\x02\x04\x04\x12\x03u\x02\n\n\
    \x0c\n\x05\x04\x06\x02\x04\x05\x12\x03u\x0b\x11\n\x0c\n\x05\x04\x06\x02\
    \x04\x01\x12\x03u\x12\x1b\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03u\x1e\
    \x1f\nx\n\x02\x04\x07\x12\x05{\0\x89\x01\x01\x1ak\x20Corresponds\x20to\
    \x20SampleTextProto\x20in\n\x20google3/java/com/google/fonts/backend/spa\
    nner/google_fonts_proto.proto\n\n\n\n\x03\x04\x07\x01\x12\x03{\x08\x17\n\
    \x0b\n\x04\x04\x07\x02\0\x12\x03|\x02$\n\x0c\n\x05\x04\x07\x02\0\x04\x12\
    \x03|\x02\n\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03|\x0b\x11\n\x0c\n\x05\
    \x04\x07\x02\0\x01\x12\x03|\x12\x1f\n\x0c\n\x05\x04\x07\x02\0\x03\x12\
    \x03|\"#\n\x0b\n\x04\x04\x07\x02\x01\x12\x03}\x02'\n\x0c\n\x05\x04\x07\
    \x02\x01\x04\x12\x03}\x02\n\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03}\x0b\
    \x11\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03}\x12\"\n\x0c\n\x05\x04\x07\
    \x02\x01\x03\x12\x03}%&\n\x0b\n\x04\x04\x07\x02\x02\x12\x03~\x02\x1d\n\
    \x0c\n\x05\x04\x07\x02\x02\x04\x12\x03~\x02\n\n\x0c\n\x05\x04\x07\x02\
    \x02\x05\x12\x03~\x0b\x11\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03~\x12\
    \x18\n\x0c\n\x05\x04\x07\x02\x02\x03\x12\x03~\x1b\x1c\n\x0b\n\x04\x04\
    \x07\x02\x03\x12\x03\x7f\x02\x1d\n\x0c\n\x05\x04\x07\x02\x03\x04\x12\x03\
    \x7f\x02\n\n\x0c\n\x05\x04\x07\x02\x03\x05\x12\x03\x7f\x0b\x11\n\x0c\n\
    \x05\x04\x07\x02\x03\x01\x12\x03\x7f\x12\x18\n\x0c\n\x05\x04\x07\x02\x03\
    \x03\x12\x03\x7f\x1b\x1c\n\x0c\n\x04\x04\x07\x02\x04\x12\x04\x80\x01\x02\
    \x20\n\r\n\x05\x04\x07\x02\x04\x04\x12\x04\x80\x01\x02\n\n\r\n\x05\x04\
    \x07\x02\x04\x05\x12\x04\x80\x01\x0b\x11\n\r\n\x05\x04\x07\x02\x04\x01\
    \x12\x04\x80\x01\x12\x1b\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\x80\x01\
    \x1e\x1f\n\x0c\n\x04\x04\x07\x02\x05\x12\x04\x81\x01\x02\x20\n\r\n\x05\
    \x04\x07\x02\x05\x04\x12\x04\x81\x01\x02\n\n\r\n\x05\x04\x07\x02\x05\x05\
    \x12\x04\x81\x01\x0b\x11\n\r\n\x05\x04\x07\x02\x05\x01\x12\x04\x81\x01\
    \x12\x1b\n\r\n\x05\x04\x07\x02\x05\x03\x12\x04\x81\x01\x1e\x1f\n\x0c\n\
    \x04\x04\x07\x02\x06\x12\x04\x82\x01\x02\x20\n\r\n\x05\x04\x07\x02\x06\
    \x04\x12\x04\x82\x01\x02\n\n\r\n\x05\x04\x07\x02\x06\x05\x12\x04\x82\x01\
    \x0b\x11\n\r\n\x05\x04\x07\x02\x06\x01\x12\x04\x82\x01\x12\x1b\n\r\n\x05\
    \x04\x07\x02\x06\x03\x12\x04\x82\x01\x1e\x1f\n\x0c\n\x04\x04\x07\x02\x07\
    \x12\x04\x83\x01\x02\"\n\r\n\x05\x04\x07\x02\x07\x04\x12\x04\x83\x01\x02\
    \n\n\r\n\x05\x04\x07\x02\x07\x05\x12\x04\x83\x01\x0b\x11\n\r\n\x05\x04\
    \x07\x02\x07\x01\x12\x04\x83\x01\x12\x1d\n\r\n\x05\x04\x07\x02\x07\x03\
    \x12\x04\x83\x01\x20!\n\x0c\n\x04\x04\x07\x02\x08\x12\x04\x84\x01\x02\"\
    \n\r\n\x05\x04\x07\x02\x08\x04\x12\x04\x84\x01\x02\n\n\r\n\x05\x04\x07\
    \x02\x08\x05\x12\x04\x84\x01\x0b\x11\n\r\n\x05\x04\x07\x02\x08\x01\x12\
    \x04\x84\x01\x12\x1d\n\r\n\x05\x04\x07\x02\x08\x03\x12\x04\x84\x01\x20!\
    \n\x0c\n\x04\x04\x07\x02\t\x12\x04\x85\x01\x02#\n\r\n\x05\x04\x07\x02\t\
    \x04\x12\x04\x85\x01\x02\n\n\r\n\x05\x04\x07\x02\t\x05\x12\x04\x85\x01\
    \x0b\x11\n\r\n\x05\x04\x07\x02\t\x01\x12\x04\x85\x01\x12\x1d\n\r\n\x05\
    \x04\x07\x02\t\x03\x12\x04\x85\x01\x20\"\n\x0c\n\x04\x04\x07\x02\n\x12\
    \x04\x86\x01\x02#\n\r\n\x05\x04\x07\x02\n\x04\x12\x04\x86\x01\x02\n\n\r\
    \n\x05\x04\x07\x02\n\x05\x12\x04\x86\x01\x0b\x11\n\r\n\x05\x04\x07\x02\n\
    \x01\x12\x04\x86\x01\x12\x1d\n\r\n\x05\x04\x07\x02\n\x03\x12\x04\x86\x01\
    \x20\"\n\x0c\n\x04\x04\x07\x02\x0b\x12\x04\x87\x01\x02#\n\r\n\x05\x04\
    \x07\x02\x0b\x04\x12\x04\x87\x01\x02\n\n\r\n\x05\x04\x07\x02\x0b\x05\x12\
    \x04\x87\x01\x0b\x11\n\r\n\x05\x04\x07\x02\x0b\x01\x12\x04\x87\x01\x12\
    \x1d\n\r\n\x05\x04\x07\x02\x0b\x03\x12\x04\x87\x01\x20\"\n\x0c\n\x04\x04\
    \x07\x02\x0c\x12\x04\x88\x01\x02\x1c\n\r\n\x05\x04\x07\x02\x0c\x04\x12\
    \x04\x88\x01\x02\n\n\r\n\x05\x04\x07\x02\x0c\x05\x12\x04\x88\x01\x0b\x11\
    \n\r\n\x05\x04\x07\x02\x0c\x01\x12\x04\x88\x01\x12\x16\n\r\n\x05\x04\x07\
    \x02\x0c\x03\x12\x04\x88\x01\x19\x1b\n\x0c\n\x02\x04\x08\x12\x06\x8b\x01\
    \0\x8e\x01\x01\n\x0b\n\x03\x04\x08\x01\x12\x04\x8b\x01\x08\x17\n\x0c\n\
    \x04\x04\x08\x02\0\x12\x04\x8c\x01\x02\x1b\n\r\n\x05\x04\x08\x02\0\x04\
    \x12\x04\x8c\x01\x02\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\x8c\x01\x0b\
    \x11\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\x8c\x01\x12\x16\n\r\n\x05\x04\
    \x08\x02\0\x03\x12\x04\x8c\x01\x19\x1a\n\x0c\n\x04\x04\x08\x02\x01\x12\
    \x04\x8d\x01\x02\x1d\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\x8d\x01\x02\n\
    \n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\x8d\x01\x0b\x11\n\r\n\x05\x04\x08\
    \x02\x01\x01\x12\x04\x8d\x01\x12\x18\n\r\n\x05\x04\x08\x02\x01\x03\x12\
    \x04\x8d\x01\x1b\x1c\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(9);
            messages.push(FamilyProto::generated_message_descriptor_data());
            messages.push(FontProto::generated_message_descriptor_data());
            messages.push(AxisSegmentProto::generated_message_descriptor_data());
            messages.push(SourceProto::generated_message_descriptor_data());
            messages.push(SourceFileProto::generated_message_descriptor_data());
            messages.push(TargetProto::generated_message_descriptor_data());
            messages.push(FamilyFallbackProto::generated_message_descriptor_data());
            messages.push(SampleTextProto::generated_message_descriptor_data());
            messages.push(GlyphGroupProto::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(TargetTypeProto::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
